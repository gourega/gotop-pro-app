import { initializeApp } from "firebase/app";
import { 
    getAuth, 
    onAuthStateChanged, 
    signOut, 
    RecaptchaVerifier, 
    signInWithPhoneNumber, 
    signInWithEmailAndPassword,
    type User 
} from 'firebase/auth';
import { 
    getFirestore, 
    collection, 
    doc, 
    getDoc, 
    getDocs, 
    setDoc, 
    updateDoc, 
    deleteDoc,
    addDoc,
    serverTimestamp,
    writeBatch
} from 'firebase/firestore';
import { 
    getStorage, 
    ref, 
    uploadBytes, 
    getDownloadURL 
} from 'firebase/storage';

import type { User as AppUser, PendingPurchase, TrainingModule } from '../types';

// TODO: Remplacez ces valeurs par votre propre configuration Firebase.
const firebaseConfig = {
  apiKey: "AIzaSyBY_pcF8fDl3f0VCnZ3qUl4AVsm7io910Q",
  authDomain: "go-top-pro.firebaseapp.com",
  projectId: "go-top-pro",
  storageBucket: "go-top-pro.firebasestorage.app",
  messagingSenderId: "533358276642",
  appId: "1:533358276642:web:cf71be01f9f66b2f885a7b"
};


// Initialize Firebase
const app = initializeApp(firebaseConfig);
export const auth = getAuth(app);
const db = getFirestore(app);
const storage = getStorage(app);

// Re-exporting Firebase Auth functions and types for convenience
export { onAuthStateChanged, signOut, RecaptchaVerifier, signInWithPhoneNumber, signInWithEmailAndPassword };
export type { User };


// --- USER DATA ---

export const getUserData = async (uid: string): Promise<AppUser | null> => {
    try {
        const docRef = doc(db, 'users', uid);
        const docSnap = await getDoc(docRef);
        if (docSnap.exists()) {
            return { uid, ...docSnap.data() } as AppUser;
        }
        console.log("No such user document!");
        return null;
    } catch (error) {
        console.error("Error getting user data:", error);
        throw error;
    }
};

export const updateUserData = async (uid: string, data: Partial<AppUser>) => {
    try {
        const userRef = doc(db, 'users', uid);
        await updateDoc(userRef, data);
    } catch (error) {
        console.error("Error updating user data:", error);
        throw error;
    }
};

export const uploadProfilePicture = async (uid: string, file: File): Promise<string> => {
    try {
        const storageRef = ref(storage, `profile-pictures/${uid}/${file.name}`);
        const snapshot = await uploadBytes(storageRef, file);
        const downloadURL = await getDownloadURL(snapshot.ref);
        return downloadURL;
    } catch (error) {
        console.error("Error uploading profile picture:", error);
        throw error;
    }
};


// --- QUIZ & PURCHASE FLOW ---

export const savePendingPurchase = async (purchaseData: { phone: string; modules: TrainingModule[]; totalPrice: number; }) => {
    try {
        await addDoc(collection(db, 'pendingPurchases'), {
            ...purchaseData,
            timestamp: serverTimestamp()
        });
    } catch (error) {
        console.error("Error saving pending purchase: ", error);
        throw new Error("Could not save your request. Please try again.");
    }
};


// --- ADMIN FUNCTIONS ---

export const getPendingPurchases = async (): Promise<PendingPurchase[]> => {
    try {
        const querySnapshot = await getDocs(collection(db, "pendingPurchases"));
        return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as PendingPurchase));
    } catch (error) {
        console.error("Error fetching pending purchases: ", error);
        return [];
    }
};

export const approvePurchase = async (purchase: PendingPurchase, firstName: string, lastName: string) => {
    if (!purchase.id) {
        throw new Error("Purchase ID is missing.");
    }
    const batch = writeBatch(db);

    // Creates a new user document in the 'users' collection.
    // IMPORTANT: This creates a user data record BEFORE the user has authenticated.
    // The document ID is auto-generated by Firestore, it is NOT the Firebase Auth UID.
    // A separate mechanism is required to associate this record with the user's
    // Auth UID when they log in for the first time.
    const newUserRef = doc(collection(db, "users"));
    
    const newUserData: Partial<AppUser> = {
        phone: purchase.phone,
        firstName,
        lastName,
        purchasedModules: purchase.modules,
        progress: {},
        badges: [],
        geminiCredits: 3 // Starting bonus
    };
    batch.set(newUserRef, newUserData);

    const pendingPurchaseRef = doc(db, 'pendingPurchases', purchase.id);
    batch.delete(pendingPurchaseRef);

    try {
        await batch.commit();
    } catch (error) {
        console.error("Error approving purchase: ", error);
        throw error;
    }
};

export const getUsers = async (): Promise<AppUser[]> => {
    const querySnapshot = await getDocs(collection(db, "users"));
    return querySnapshot.docs.map(doc => ({ uid: doc.id, ...doc.data() } as AppUser));
};

export const deleteUserAndData = async (userId: string) => {
    try {
        await deleteDoc(doc(db, "users", userId));
        // Note: This only deletes the Firestore document. 
        // Deleting a user from Firebase Authentication requires Admin SDK on a backend.
    } catch (error) {
        console.error("Error deleting user data: ", error);
        throw error;
    }
};